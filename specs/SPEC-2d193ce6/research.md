# 技術リサーチ: SPEC-2d193ce6

## APNs統合方法

**決定**: node-apn v6.0+ (HTTP/2ベース)

**理由**:
- HTTP/2プロトコルを使用（Apple推奨、レガシーバイナリプロトコルは非推奨）
- Promise/async-awaitサポートで現代的なNode.js開発に適合
- 証明書ベース（.p12/.p8）とトークンベース認証の両方をサポート
- アクティブメンテナンス、TypeScript型定義あり

**検討した代替案**:
- **native HTTP/2 (Node.js標準)**: 低レベルすぎる、エラーハンドリングが複雑、却下
- **apn2**: 古いライブラリ、最終更新が2年前、メンテナンス停止の懸念、却下
- **Firebase Admin SDK (APNs経由)**: FCM経由でAPNsに送信可能だが、APNs固有の機能（優先度、collapse ID等）が制限される、却下

**実装ノート**:
- .p8トークンベース認証を優先（証明書更新の手間削減）
- Sandbox環境と Production環境を環境変数で切り替え
- 無効なトークンのフィードバック（410 Unregistered）を処理してDB更新
- 接続プーリング有効化（パフォーマンス向上）

---

## FCM統合方法

**決定**: firebase-admin SDK v12.0+

**理由**:
- Google公式SDK、安定性とメンテナンス保証
- サービスアカウントキー（JSON）による認証が簡単
- TypeScript完全サポート
- トピック、デバイストークン、条件ベース送信すべてサポート
- Androidだけでなく、iOSへの送信もサポート（FCM経由）

**検討した代替案**:
- **node-gcm**: 古いGCM（Google Cloud Messaging）SDK、FCMに移行済みのため使用不可、却下
- **fcm-node**: サードパーティライブラリ、公式SDKより機能が少ない、却下
- **直接HTTP v1 API呼び出し**: 低レベル、OAuth2トークン管理が複雑、却下

**実装ノート**:
- サービスアカウントキー（JSON）を環境変数または安全なストレージに保存
- メッセージ優先度（high/normal）を設定可能に
- データメッセージとNotificationメッセージの両方をサポート
- FCMのレート制限（1,000,000メッセージ/分）を考慮

---

## 認証方式

**決定**: API Keyベース認証（`X-API-Key`ヘッダー）

**理由**:
- ゲーム開発者向けにシンプルで導入が容易
- サーバー間通信（バックエンド→通知サーバー）に適している
- OAuth2のような複雑なフローが不要
- APIキーの発行・管理が容易（管理画面不要の場合は環境変数で固定も可能）

**検討した代替案**:
- **OAuth2**: 複雑すぎる、ゲーム開発者の学習コストが高い、サーバー間通信にはオーバースペック、却下
- **JWT**: ステートレス認証には優れているが、APIキーより実装が複雑、トークン更新ロジックが必要、却下
- **Basic認証**: 安全性が低い（Base64エンコードのみ）、HTTPS必須だが推奨されない、却下

**実装ノート**:
- APIキーはUUIDv4形式（128ビットランダム）
- データベースにハッシュ化して保存（bcryptまたはargon2）
- レート制限をAPIキー単位で適用
- 将来的には管理画面でAPIキー発行・無効化機能を追加可能

---

## レート制限実装

**決定**: @fastify/rate-limit プラグイン + Redisバックエンド（オプション）

**理由**:
- Fastify公式プラグイン、統合が簡単
- インメモリ（単一サーバー）とRedis（マルチサーバー）の両方をサポート
- APIキー単位、IPアドレス単位のレート制限が可能
- カスタマイズ可能な制限ルール（エンドポイント別）

**検討した代替案**:
- **express-rate-limit**: Express専用、Fastifyでは使用不可、却下
- **自作実装**: 車輪の再発明、バグの可能性、メンテナンス負担、却下
- **nginx rate-limit**: インフラ層での制限、アプリケーションレベルの柔軟性なし、却下

**実装ノート**:
- `/api/v1/notifications`エンドポイント: 100リクエスト/分（APIキー単位）
- `/api/v1/tokens`エンドポイント: 500リクエスト/分（APIキー単位）
- APNs/FCMのレート制限を超えないよう、送信キューで調整
- レート制限超過時は429 Too Many Requestsレスポンス、Retry-Afterヘッダー付与

**APNs/FCMレート制限考慮**:
- APNs: 接続あたり500ストリーム同時、実質的なレート制限なし（ただし過剰送信で一時的にブロックされる可能性）
- FCM: 1,000,000メッセージ/分（プロジェクト単位）

---

## 配信状態管理

**決定**: データベース同期書き込み + 非同期フィードバック処理

**理由**:
- 通知送信時にDeliveryLogを`pending`状態で即座に作成（同期）
- APNs/FCMからのレスポンスを受け取り次第、状態を`success`/`failed`に更新（同期）
- シンプルで理解しやすい、Webhookやポーリングが不要
- APNs/FCMのフィードバック（無効トークン等）を即座にデータベースに反映

**検討した代替案**:
- **Webhook方式**: APNs/FCMからのフィードバックをWebhookで受信。複雑、インフラ設定必要（パブリックエンドポイント）、却下
- **ポーリング方式**: 定期的にAPNs/FCMのフィードバックAPIをポーリング。リアルタイム性が低い、不要なAPI呼び出し、却下
- **メッセージキュー（RabbitMQ/SQS）**: オーバーエンジニアリング、現時点の規模では不要、却下

**実装ノート**:
- 通知送信は非同期ではなく、同期的に実行（レスポンスを待つ）
- 配信失敗時の自動リトライ: 指数バックオフで最大3回
- 無効なデバイストークン（APNs 410 Unregistered、FCM InvalidRegistration）を検出した場合、Deviceテーブルから削除
- 大量送信時はバッチ処理（100デバイスずつ）を使用してDB負荷軽減

---

## まとめ

すべての要明確化が解決され、技術スタックが確定しました:

- **APNs**: node-apn v6.0+ (HTTP/2、.p8トークン認証)
- **FCM**: firebase-admin v12.0+ (サービスアカウントキー認証)
- **認証**: API Keyベース（`X-API-Key`ヘッダー）
- **レート制限**: @fastify/rate-limit（APIキー単位、Redisオプション）
- **配信状態**: DB同期書き込み、非同期フィードバック処理、自動リトライ

次のフェーズ（Phase 1）に進む準備が整いました。
